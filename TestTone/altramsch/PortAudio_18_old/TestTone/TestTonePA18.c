/*
 * This is the source code for TestTone, which is based on PortAudio V18 (http://www.portaudio.com).
 *
 * TestTone is part of MATAA. MATAA is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * MATAA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with MATAA; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 * 
 * Copyright (C) 2006, 2007 Matthias S. Brennwald.
 * Contact: info@audioroot.net
 * Further information: http://www.audioroot.net/MATAA.html
 */


/* 
TestTone is a console program that reads a test tone from a text file. This tone is then played through the default audio output device, and simultaneously recorded through the default audio input device. Alternatively, if no input file is given, then a default signal is generated.

TestTone makes use of PortAudio to communicate with the audio device (see http://www.portaudio.com). This should allow TestTone to be compiled on several platforms.

TestTone is invoked from the console as follows:
console> TestTone testSignal.in > testSignal.out
(this reads the text file testSignal.in which contains the samples of the input signal (mono, one sample per line, max. value = 1, min. value = -1). The result is written to STDIO, here it is piped into the file 'testSignal.out'.

console> TestTone  > testSignal.out
(As above, but without specifying an input signal. A default signal is generated by TestTone)
*/

#include <stdio.h>
#include <stdlib.h>
#include "portaudio.h"

#define PI		(3.141592653589793)
// #define SAMPLE_RATE	(8000)
// #define SAMPLE_RATE	(11025)
// #define SAMPLE_RATE	(22050)
// #define SAMPLE_RATE	(32000)
// #define SAMPLE_RATE	(44100)
// #define SAMPLE_RATE	(48000)
// #define SAMPLE_RATE	(96000)
// #define SAMPLE_RATE	(192000)
// #define NUM_CHANNELS    (2)
#define PA_SAMPLE_TYPE  paFloat32
typedef float SAMPLE;

typedef struct
{
    unsigned long	numFrames;
    unsigned long	processedFrames;
    unsigned int	numInputChannels;
    unsigned int	numOutputChannels;
    float		samplingRate;
    SAMPLE		*inputSamples;
    SAMPLE		*outputSamples;
}
paTestData, *paTestDataPtr;

/* This routine will be called by the PortAudio engine when audio is needed.
** It may be called at interrupt level on some machines so don't do anything
** that could mess up the system like calling malloc() or free().
*/
static int RecordAndPlayCallback(
                            void *inputBuffer,
                            void *outputBuffer,
                            unsigned long framesPerBuffer,
                            PaTimestamp outTime,
                            void *userData )
{
    unsigned long iF,iFmax,remainingFrames,iC;
    paTestData* data;
    int finished;
    
/* Cast data passed through stream to our structure. */
    data = (paTestDataPtr)userData;
    
/* Handle sound output buffer */
    SAMPLE *out = (SAMPLE*)outputBuffer;
    //(void) outTime; /* Prevent unused variable warnings. */
    //(void) inputBuffer;
    remainingFrames = data->numFrames - data->processedFrames;
    if (remainingFrames > framesPerBuffer)
    {
        iFmax=framesPerBuffer;
        finished=0;
    }
    else
    { /* last buffer... */
        iFmax=remainingFrames;
        finished=1;
    }
    for( iF=0; iF<iFmax; iF++ )
    {
        for( iC=0; iC<data->numOutputChannels; iC++ ) *out++ = data->outputSamples[(iF+data->processedFrames)*data->numOutputChannels+iC];
    }

/* Handle sound input buffer */
    SAMPLE *in = (SAMPLE*)inputBuffer;
    for( iF=0; iF<iFmax; iF++ )
    {
        for( iC=0; iC<data->numInputChannels; iC++ ) data->inputSamples[(iF+data->processedFrames)*data->numInputChannels+iC]=*in++;
    }
    
/* Prepare for next callback-cycle: */    
    data->processedFrames += iFmax;

return finished;
}


/*******************************************************************/
int main(int argc, char *argv[]);
int main(int argc, char *argv[])
{
    PortAudioStream	*stream;
    PaError	err;
    paTestData	data;
    unsigned long	iF,iC;
    unsigned long	numBytes;
    SAMPLE		*testSignal;

    
    /* check for proper input */
	
	// argv[1]: sample rate in Hz
	// argv[2]: input file name (optional)
	
	
    argc -=1; /* first argument is call to TestTone itself */
	
    if (argc == 0) {
        printf("Error: not enough input arguments.\n");
		printf("Usage:\n");
		printf("'TestTone 44100' plays a 1-kHz sine with a sampling rate of 44.1 kHz and records the response signal.\n");
		printf("'TestTone 44100 myTestSignal' plays the test-signal samples in the ASCII-file 'myTestSignal' at a sampling rate of 44.1 kHz and records the response signal.\n\n");
		printf("TestTone is part of MATAA. MATAA is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.\n\n");
		printf("MATAA is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n\n");
		printf("You should have received a copy of the GNU General Public License along with MATAA; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n");
		printf("Copyright (C) 2006, 2007 Matthias S. Brennwald.\nContact: info@audioroot.net\nFurther information: http://www.audioroot.net/MATAA.html\n");
		exit(1);
	}

// Init PortAudio:
    err = Pa_Initialize();
    if( err != paNoError ) goto error;

// Get audio devices info:
	PaDeviceID inputDevice = Pa_GetDefaultInputDeviceID( );
	PaDeviceInfo* inputInfo = Pa_GetDeviceInfo( inputDevice );
	PaDeviceID outputDevice = Pa_GetDefaultOutputDeviceID( );
	PaDeviceInfo* outputInfo = Pa_GetDeviceInfo( outputDevice );

// Prepare data:
    data.processedFrames = 0;
    data.numInputChannels = inputInfo->maxInputChannels;
    data.numOutputChannels = outputInfo->maxOutputChannels;
	data.samplingRate = atof(argv[1]);
	
	
    if (argc == 1) { /* no input file is given, use some default signal instead */
        printf("%% No input file given! Using default signal instead: 1 kHz sine, 1 sec duration\n");
        data.numFrames=data.samplingRate; /* determines signal duration */
        float f=1000.0; /* frequency of test tone */
        testSignal = (SAMPLE*)malloc(data.numFrames*sizeof(SAMPLE));
        if (!testSignal) return 1;
        for (iF=0; iF<data.numFrames; iF++) testSignal[iF]=sin((float)iF/data.samplingRate*f*2.0*PI);
    }

    if (argc == 2) /* read the input file specified in argv[2] */
    {
        char	s[1000];
        FILE	*inFile;
        unsigned long	iLine=0;
        
        printf("%% Input file: %s\n", argv[2]);
        
    	inFile=fopen(argv[2],"r");
        if (!inFile) return 1;
        /* get number of input signal frames */
        data.numFrames=0;
        while (fgets(s,1000,inFile)!=NULL) {
            data.numFrames +=1;
        }
        testSignal = (SAMPLE*)malloc(data.numFrames*sizeof(SAMPLE));
        if (!testSignal) return 1;
        fseek(inFile,0,SEEK_SET); /* go back to the beginning of the file */
        while (fgets(s,1000,inFile)!=NULL) {
            testSignal[iLine++]=atof(s);
        }
        fclose(inFile);
    }



/* move the testSignal to data.outputSamples */
    
    numBytes = data.numFrames * data.numOutputChannels * sizeof(SAMPLE);
    data.outputSamples= (SAMPLE *) malloc( numBytes );
    if( data.outputSamples == NULL )
    {
        printf("Could not allocate output frames buffer");
        exit(1);
    }
    
    for( iF=0; iF<data.numFrames; iF++ ) /* initialize output frames: */
    {
        for( iC=0; iC<data.numOutputChannels;iC++ ) data.outputSamples[iF*data.numOutputChannels+iC] = testSignal[iF];
    }
    free(testSignal);
    
    data.inputSamples= (SAMPLE *) malloc( numBytes );
    if( data.inputSamples == NULL )
    {
        printf("Could not allocate output frames buffer");
        exit(1);
    }
    for( iF=0; iF<data.numFrames; iF++ ) /* initialize input frames: */
    {
        for( iC=0; iC<data.numInputChannels;iC++ )  data.inputSamples[iF*data.numInputChannels+iC] = 0;
    }

	
/*	long	inDevID,outDevID;
	inDevID=Pa_GetDefaultInputDeviceID();
	outDevID=Pa_GetDefaultOutputDeviceID();
	
	PaDeviceInfo *inDevInfo, *outDevInfo;
	inDevInfo = Pa_GetDeviceInfo(inDevID);
	outDevInfo = Pa_GetDeviceInfo(outDevID); */

    /* Record and play some audio. -------------------------------------------- */
	
    printf("%% "); /* print a '%' before the 'PortAudio on OS X - Latency = 1024 frames, 23 msec' message produced by the next command */
    err = Pa_OpenStream(
              &stream,
              inputDevice,
              data.numInputChannels,               /* number of input channels */
              PA_SAMPLE_TYPE,
              NULL,
              outputDevice,
              data.numOutputChannels,
              PA_SAMPLE_TYPE,
              NULL,
              data.samplingRate,
              1024,            /* frames per buffer */
              0,               /* number of buffers, if zero then use default minimum */
              0, //paDitherOff,    /* flags */
              RecordAndPlayCallback,
              &data );
    if( err != paNoError ) goto error;
	
    err = Pa_StartStream( stream );
    if( err != paNoError ) goto error;
    // printf("Now playing and recording %d frames...\n",data.numFrames); fflush(stdout);

    while( Pa_StreamActive( stream ) )
    {
        Pa_Sleep(1); /* sleep while audio I/O */
    }
    err = Pa_CloseStream( stream );
    if( err != paNoError ) goto error;
    // printf("...done!\n",data.numFrames); fflush(stdout);
    Pa_Terminate();

/* output the recorded data to stdio */
    /* print header */
    printf("%% Number of frames = %d\n", data.numFrames);
    printf("%% Number of channels = %d\n", data.numInputChannels);
    printf("%% Sampling rate = %f Hz\n", data.samplingRate);
    printf("%% time (s)\t");
    for( iC=0; iC<data.numInputChannels;)
    {
        iC++;
        printf("channel-%d ",iC);
    }
    printf("\n");
    /* output recorded frames... */
    float frameTime;
    for( iF=0; iF<data.numFrames; iF++ )
    {
	frameTime = (float)iF / data.samplingRate;
        printf("%E",frameTime); /* print frame sampling time */
        for( iC=0; iC<data.numInputChannels;iC++ )
        {
            printf("\t");
            printf("%E",data.inputSamples[iF*data.numInputChannels+iC]);
        }
        printf("\n");
    }
    free(data.inputSamples);
    free(data.outputSamples);
    return 0;
error:
    Pa_Terminate();
    fprintf( stderr, "An error occured while using the portaudio stream\n" );
    fprintf( stderr, "Error number: %d\n", err );
    fprintf( stderr, "Error message: %s\n", Pa_GetErrorText( err ) );
    return -1;
}